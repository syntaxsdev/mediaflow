Mediaflow — Presigned Uploads v1 (Stateless, Backend-Keyed)
1) Scope (this slice only)

Direct-to-storage uploads using backend-generated keys.

Mediaflow returns presigned URL(s); no server-side upload sessions.

Out of scope: processing, thumbnails, HLS, moderation, publish states.

2) Actors & Flow

Client (web/app/CLI)

Product Backend (authn/authz; mints key_base)

Mediaflow (presigns; stateless)

Object Storage (e.g., S3/GCS)

Sequence

Client → Backend: filename, mime, size_bytes, kind, profile.

Backend validates policy → mints key_base (+ optional shard) & chooses ext → calls Mediaflow /presign (server→server) or proxies result to client.

Mediaflow computes object_key from template + {key_base, ext, shard?} → returns presigned URL(s) + UploadIntent token.

Client uploads directly to storage (single PUT or multipart).

Client → Backend: notify completion with object_key; Backend verifies via HEAD.

3) Pathing (derivable, no dates)

Canonical raw path:
raw/{shard?}/{key_base}.{ext}

Hash sharding (optional, recommended ≥10M objects):
shard = sha1(key_base)[0:2] (hex)

Downstream artifacts (e.g., proxies, posters) must derive from key_base using fixed suffix/patterns, but are not part of this slice.

4) UploadIntent (JWT) — the “stateless contract”

Alg: ES256/RS256, short TTL (5–15 min)

Claims (required):

sub: user/actor id

iss: product backend or mediaflow

aud: "mediaflow-upload"

iat, exp

bucket: target bucket

mime, size_max

key_base, ext, shard?

object_key: fully resolved raw path

strategy: "single" | "multipart"

part_size (if multipart)

headers_required: map (e.g., Content-Type, SSE)

kid: signing key id (for rotation)

Mediaflow must reject requests if token invalid/expired or path/header mismatch.

5) API (stateless presign)
5.1 POST /v1/uploads/presign

Auth: product backend → mediaflow (server→server) or client → backend → mediaflow (proxy)

Request: PresignRequest

key_base (string, ULID/KSUID generated by backend)

ext (string; from MIME allowlist)

bucket (string)

mime (string)

size_bytes (int)

kind (image|video)

profile (string; for policy lookup)

multipart (auto|force|off)

shard (string, optional)

Response: PresignResponse

intent_token (JWT UploadIntent)

key_base

object_key

expires_at (RFC3339)

strategy (single|multipart)

upload:

if single: { method, url, headers } (include If-None-Match: *)

if multipart:

part_size (int)

create: { method, url, headers }

part: { method, url_template, headers_template } or omit and use per-part endpoint (5.2)

complete: { method, url, headers }

abort: { method, url, headers }

5.2 (Optional) POST /v1/uploads/presign/part

Use only if your storage requires per-part signing.

Body: { intent_token, uploadId, partNumber }

Resp: { url, headers }

6) Validation Rules

MIME allowlist per kind/profile.

Size guard: size_bytes ≤ policy.size_max.

Key authority: only accept backend-provided key_base/ext; client filenames ignored.

Overwrite prevention (single PUT): sign with If-None-Match: *.

Multipart threshold: default > 15 MB → multipart (configurable).

Headers: always include Content-Type and SSE (AES256 or KMS).

7) Storage & CORS

Bucket ACLs: private; no public ACLs.

CORS: allow PUT, POST, GET, HEAD from your origins; allow headers Content-Type, Content-MD5, x-amz-server-side-encryption; Expose ETag.

Lifecycle: auto-abort stale multipart (e.g., 24h).

8) Security Checklist
Short-TTL tokens; verify aud, iss, kid.
Bind path & headers inside token; refuse mismatches.
Enforce single-use semantics at backend (reject reuse after completion).
Log key_base, object_key, mime, size_bytes, strategy, requester.

9) Error Model

unauthorized — bad/expired token

mime_not_allowed — MIME disallowed for kind/profile

size_too_large — exceeds policy

signature_invalid — JWT invalid or wrong audience/issuer

storage_denied — storage policy mismatch

bad_request — missing/invalid fields

rate_limited — presign abuse detected

Response shape

code (string), message (string), hint (optional), retry_after_seconds (optional)

10) Config Knobs (per env)

multipart_threshold_mb (default 15)

part_size_mb (e.g., 8–16)

token_ttl_seconds (e.g., 900)

signing_alg (ES256|RS256), active_kid

allowed_mimes:{ image:[], video:[] }

bucket, region

path_template_raw:"raw/{shard?}/{key_base}.{ext}"

enable_sharding:true|false

11) CLI Contract (reference UX)

mediaflow presign --mime video/quicktime --size 104857600 --kind video --profile listing --key-base <ULID> --ext mov

Prints PresignResponse JSON to stdout (including object_key and upload URLs).

Client/CLI performs upload and returns object_key to backend.

12) Non-Goals / Future

No DB upload sessions (stateless by design).

No completion callbacks from Mediaflow.

Processing/publish flows added in later slices; paths derived from the same key_base.

13) Open Decisions (default recommendations)

Per-part presign vs URL template? → Template first, per-part endpoint only if required by provider.

Who calls /presign? → Backend calls Mediaflow; optionally proxy to client for simpler apps.

Sharding on/off? → On for large buckets; fixed 2-char hex prefix.